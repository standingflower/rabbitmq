package cn.itcast.rabbitmq;

public class text {

    /**
     * RabbitMQ：
     *  RabbitMQ基于AMQP(Advanced Message Queuing Protocol)协议(应用层协议)
     *  RabbitMQ不是Apache的项目，采用erlang(面向并发的编程语言)开发
     *  RabbitMQ有如下端口：
     *      15672:RabbitMQ Web管理端口
     *      25672:RabbitMQ集群端口
     *      5672:AMQP端口
     *  RabbitMQ可以添加不同用户，并为设置权限：
     *   超级管理员(administrator)：
     *      可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。
     *   监控者(monitoring) ：
     *      可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)
     *   策略制定者(policymaker)：
     *      可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息。
     *   普通管理者(management)：
     *      仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。
     *   其他:
     *      无法登陆管理控制台，通常就是普通的生产者和消费者。
     * 生产者，消费者都会创队列，如果队列存在，就不会创建
     *  并且创建队列时的参数必须是一致，否则会报错
     *
     * 消息的确认类型：
     *  自动确认：消息取出后，自动从队列中移出
     *  手动确认：消息被取出后，需要消费者确认后才会从队列中移出，消息被取出后，会标记
     *           为不可用，等待消费者确认，如果消费者不确认，消息一直处于队列中
     *
     * 交换机不存储消息
     * 一个交换机可以绑定对个队列，一个队列可以绑定多个交换机
     *
     *
     *  RabbitMQ：
     *   queue：一个消息只能被一个消费者消费
     *      一般模式：p---MQ---c
     *      work模式：p---MQ---c1
     *                     ---c2
     *               轮序模式 + 能者多劳模式
     *   topic：
     *      fanout：交换机与队列只做简单绑定
     *      direct：交换机与队列进行路由
     *      topic： 交换机与队列进行模糊路由
     *              # 匹配一个或多个单词
     *              * 匹配一个单词
     *   topic模式：交换机根据消息的路由key将消息发送对应用的队列中，
     *              所以，可以在topic下的队列上使用work模式
     *
     *   交换机不存储消息
     *
     *   这里的Channel和NIO中Channel类似，多路复用的双向数据流通道，复用一个TCP连接
     *
     *   JMS和AMQP：
     *      AMQP可跨语言，跨平台，而JMS基于Java
     *      AMQP的队列模式比JMS多(5:2)
     *      JMS支持传递数据类型多，AMQP传输的是byte，然后进行序列化
     *      JMS基于java api，AMQP基于网络协议
     *
     * 如何确保消息被RabbitMQ接收：
     *  RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。
     * 	发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。
     *  一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。
     * 	发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。
     * 	当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。
     *
     * 如何确保消息接收方消费了消息：
     * 	自动确认 + 消费者确认
     * 	RabbitMQ没有超时机制，消费者一直未发确认消息，消息将一直存在MQ中
     * 	特例：
     * 		消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，
     * 		然后重新分发给下一个订阅的消费者。(可能会导致消息被重复消费，可根据bizId去重[消息头中])
     *
     * 		消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。
     *
     * 消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；
     * 消息消费时，要求消息体中必须要有一个bizId作为去重和幂等的依据，避免同一条消息被重复消费。
     *
     * 消息基于Channel传输，减少TCP连接
     *
     * 消息默认使用循环（round-robin）的方式发送给消费者/能者多劳
     *
     * vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ  server
     *
     *
     *
     */
}
